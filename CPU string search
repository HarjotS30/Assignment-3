#include <iostream>
#include <vector>
#include <string>
#include <omp.h>
#include <chrono>

// Function to perform the Boyer-Moore search on a substring of the text
// between indices [startIdx, endIdx).
int boyerMooreSearchCPU(const std::string &text, const std::string &pattern, int startIdx, int endIdx) {
    int textLength = endIdx - startIdx;
    int patternLength = pattern.size();
    int badChar[256] = {-1};

// Initialize the bad character table to -1.
    for (int i = 0; i < 256; ++i) badChar[i] = -1;
// Fill the bad character table with the last occurrence index of each character in the pattern.
    for (int i = 0; i < patternLength; ++i) badChar[pattern[i]] = i;

// Start position of the current search window in the text segment.
    int i = 0; 

// Search loop to match the pattern within the text segment.
    while (i <= textLength - patternLength) {
        int j = patternLength - 1; // Start comparing from the end of the pattern.

// Match characters from the end of the pattern to the beginning.
        while (j >= 0 && pattern[j] == text[startIdx + i + j]) {
            j--;
        }

// If the entire pattern matches, return the starting position.
        if (j < 0) {
            return startIdx + i;
        }
 // Calculate the shift based on the bad character rule.
        int shift = std::max(1, j - badChar[text[startIdx + i + j]]);
        i += shift; // Move the pattern window forward by the shift amount.
    }

    return -1; // Return -1 if no match is found in this segment.
}

// Function to perform parallel Boyer-Moore search using OpenMP.
std::vector<int> boyerMooreSearchParallelCPU(const std::string &text, const std::string &pattern, int numThreads) {
    int textLength = text.size();             // Total length of the text.
    int chunkSize = textLength / numThreads;  // Divide the text into chunks for each thread.
    std::vector<int> results(numThreads, -1); // Store results for each thread.

// Parallel loop using OpenMP to perform search in each chunk.
    #pragma omp parallel for num_threads(numThreads)
    for (int i = 0; i < numThreads; ++i) {
        int startIdx = i * chunkSize; // Start index of the current chunk.
        int endIdx = (i == numThreads - 1) ? textLength : startIdx + chunkSize; // End index of the chunk.

// Perform Boyer-Moore search on this chunk of text.
        results[i] = boyerMooreSearchCPU(text, pattern, startIdx, endIdx);
    }

    return results; // Return results from all threads.
}

int main() {
    std::string text = "ABAAABCDABAAABCDABCDABC"; // Input text to search.
    std::string pattern = "ABCD";                 // Pattern to search for.
    int numThreads = 4;                           // Number of threads for parallel execution.

// Measure the start time of the search.
    auto start = std::chrono::high_resolution_clock::now();

// Perform parallel Boyer-Moore search.
    std::vector<int> results = boyerMooreSearchParallelCPU(text, pattern, numThreads);

// Measure the end time of the search.
    auto end = std::chrono::high_resolution_clock::now();
    double elapsed = std::chrono::duration<double, std::milli>(end - start).count(); // Calculate elapsed time.

// Output the match positions.
    std::cout << "Match positions: ";
    for (int i : results) {
        if (i != -1) std::cout << i << " "; // Print valid match positions only.
    }
    std::cout << "\nTime elapsed: " << elapsed << " ms\n"; // Print elapsed time.

    return 0; // Exit the program.
}
